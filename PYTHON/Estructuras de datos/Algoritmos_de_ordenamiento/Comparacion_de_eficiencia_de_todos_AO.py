# -*- coding: utf-8 -*-
"""actividad 2 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IgPz9Ex8k9M945VBOmwQVpmj6UrlO4Tl

generador numeros aleatorios
"""

import random

n=3

aleatorios = [random.randint(1,100) for i in range(n)]
print(aleatorios)


array = []
size = [100]

for i in size:
  array = [random.randint(0,100) for _ in range(i)]
  print(array)

"""**1 burbuja**"""

import time
import random
import matplotlib.pyplot as plt
import numpy as np

#metodo de ordenamiento burbuja
def burbuja(lista):
  for i in range (0,len(lista)-1):
    for j in range (0,len(lista)-i-1):
      if(lista[j]>lista[j+1]):
        lista[j],lista[j+1]=lista[j+1],lista[j]

  return lista

#tama침o de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_burbuja = []



#generar lista aleatoria
for i1 in size:
  array = [random.randint(0,100) for _ in range(i1)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time1 = time.perf_counter()
  Lista_ordenada_burbuja = burbuja(array)
  end_time1 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time1}")
  print(f"tiempo final: {end_time1}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_burbuja}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time1 - start_time1
  execution_times_burbuja.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tama침o {i1}: {tiempo_transcurrido} segundos")
  print("\n")


#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecuci칩n       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_burbuja):
    print(f"Tama침o: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gr치fica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_burbuja, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tama침o de la lista')
plt.ylabel('Tiempo de ejecuci칩n (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Burbuja')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()



# Guardar los 칰ltimos tiempos y tama침o
endtime1 = end_time1
lastsize1 = i1

"""**2 burbuja mejorada**"""

import random
import time
import matplotlib.pyplot as plt

#metodo de ordenamiento burbuja mejorado
def burbuja_mejorado(lista):
    i = 0
    control = True

    while (i <= len(lista)-2) and control:
        control = False
        for j in range(0, len(lista)-i-1):
            if(lista[j] > lista[j+1]):
                lista[j], lista[j+1] = lista[j+1], lista[j]
                control = True
        i += 1
    return lista


#tama침o de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_burbuja_mejorado = []

#generar lista aleatoria
for i2 in size:
  array = [random.randint(0,100) for _ in range(i2)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time2 = time.perf_counter()
  Lista_ordenada_burbuja_mejorado = burbuja_mejorado(array)
  end_time2 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time2}")
  print(f"tiempo final: {end_time2}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_burbuja_mejorado}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time2 - start_time2
  execution_times_burbuja_mejorado.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tama침o {i2}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecuci칩n       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_burbuja_mejorado):
    print(f"Tama침o: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gr치fica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_burbuja_mejorado, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tama침o de la lista')
plt.ylabel('Tiempo de ejecuci칩n (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Burbuja Mejorado')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime2= end_time2
lastsize2 = i2

"""**3 Coctel**"""

import random
import time
import matplotlib.pyplot as plt


#metodo de ordenamiento c칩ctel o burbuja bidireccional
def coctel(lista):
    izquierda = 0
    derecha = len(lista) - 1
    control = True
    while (izquierda < derecha) and control:
        control = False
        for i in range(izquierda, derecha):
            if(lista[i] > lista[i+1]):
                control = True
                lista[i], lista[i+1] = lista[i+1], lista[i]
        derecha -= 1
        for j in range(derecha, izquierda, -1):
            if(lista[j] < lista[j-1]):
                control = True
                lista[j], lista[j-1] = lista[j-1], lista[j]
        izquierda += 1
    return lista


#tama침o de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000
,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_coctel = []


#generar lista aleatoria
for i3 in size:
  array = [random.randint(0,100) for _ in range(i3)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time3 = time.perf_counter()
  Lista_ordenada_coctel = coctel(array)
  end_time3 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time3}")
  print(f"tiempo final: {end_time3}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_coctel}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time3 - start_time3
  execution_times_coctel.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tama침o {i3}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecuci칩n       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_coctel):
    print(f"Tama침o: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gr치fica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_coctel, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tama침o de la lista')
plt.ylabel('Tiempo de ejecuci칩n (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Coctel')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime3 = end_time3
lastsize3 = i3

"""**4 Seleccion**"""

import time
import random
import matplotlib.pyplot as plt

#metodo de ordenamiento seleccion
def seleccion(lista):
    """M칠todo de ordenamiento selecci칩n."""
    for i in range(0, len(lista)-1):
        minimo = i
        for j in range(i+1, len(lista)):
            if(lista[j] < lista[minimo]):
                minimo = j
        lista[i], lista[minimo] = lista[minimo], lista[i]
    return lista

array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_seleccion = []
#generar lista aleatoria
for i4 in size:
  array = [random.randint(0,100) for _ in range(i4)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time4 = time.perf_counter()
  Lista_ordenada_seleccion = seleccion(array)
  end_time4 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time4}")
  print(f"tiempo final: {end_time4}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_seleccion}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time4 - start_time4
  execution_times_seleccion.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tama침o {i4}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecuci칩n       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_seleccion):
    print(f"Tama침o: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gr치fica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_seleccion, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tama침o de la lista')
plt.ylabel('Tiempo de ejecuci칩n (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Seleccion')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime4 = end_time4
lastsize4 = i4

"""**5 insercion**"""

import time
import random
import matplotlib.pyplot as plt

#metodo de ordenamiento insercion
def insercion(lista):
    """M칠todo de ordenamiento inserci칩n."""
    for i in range(1, len(lista)+1):
        k = i-1
        while (k > 0) and (lista[k] < lista[k-1]):
            lista[k], lista[k-1] = lista[k-1], lista[k]
            k -= 1
    return lista


array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_insercion = []

#generar lista aleatoria
for i5 in size:
  array = [random.randint(0,100) for _ in range(i5)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time5 = time.perf_counter()
  Lista_ordenada_insercion = insercion(array)
  end_time5 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time5}")
  print(f"tiempo final: {end_time5}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_insercion}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time5 - start_time5
  execution_times_insercion.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tama침o {i5}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecuci칩n       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_insercion):
    print(f"Tama침o: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gr치fica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_insercion, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tama침o de la lista')
plt.ylabel('Tiempo de ejecuci칩n (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Inserci칩n')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime5 = end_time5
lastsize5 = i5

"""**6 quicksort**"""

import time
import random
import matplotlib.pyplot as plt

#metodo de ordenamiento quicksort
def quicksort(lista):
    """M칠todo de ordenamiento quicksort."""
    if len(lista) <= 1:
        return lista
    else:
        pivot = lista[0]
        left = [x for x in lista[1:] if x < pivot]
        right = [x for x in lista[1:] if x >= pivot]

        return quicksort(left) + [pivot] + quicksort(right)


#tama침o de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_quicksort = []

#generar lista aleatoria
for i6 in size:
  array = [random.randint(0,100) for _ in range(i6)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time6 = time.perf_counter()
  Lista_ordenada_quicksort = quicksort(array)
  end_time6 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time6}")
  print(f"tiempo final: {end_time6}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_quicksort}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time6 - start_time6
  execution_times_quicksort.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tama침o {i6}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecuci칩n       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_quicksort):
    print(f"Tama침o: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gr치fica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_quicksort, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tama침o de la lista')
plt.ylabel('Tiempo de ejecuci칩n (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Quicksort')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime6 = end_time6
lastsize6 = i6

"""**7 mergesort**"""

import time
import random
import matplotlib.pyplot as plt


def mergesort(lista):

    if len(lista) <= 1:
        return lista
    else:
        medio = len(lista) // 2
        izquierda = []
        for i in range(0, medio):
            izquierda.append(lista[i])
        derecha = []
        for i in range(medio, len(lista)):
            derecha.append(lista[i])
        izquierda = mergesort(izquierda)
        derecha = mergesort(derecha)
        if(izquierda[medio-1] <= derecha[0]):
            izquierda += derecha
            return izquierda
        resultado = merge(izquierda, derecha)
        return resultado

def merge(izquierda,derecha):
    #mezclar las dos listas
    lista_mezclada = []
    while (len(izquierda) > 0 and (len(derecha) > 0)):
        if (izquierda[0] <= derecha[0]):
            lista_mezclada.append(izquierda.pop(0))

        else:
            lista_mezclada.append(derecha.pop(0))
    if len(izquierda) > 0:
            lista_mezclada += izquierda
    if len(derecha) > 0:
            lista_mezclada += derecha
    return lista_mezclada


#tama침o de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_mergesort = []


#generar lista aleatoria
for i7 in size:
  array = [random.randint(0,100) for _ in range(i7)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time7 = time.perf_counter()
  Lista_ordenada_mergesort = mergesort(array)
  end_time7 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time7}")
  print(f"tiempo final: {end_time7}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_mergesort}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time7 - start_time7
  execution_times_mergesort.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tama침o {i7}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecuci칩n       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_mergesort):
    print(f"Tama침o: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gr치fica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_mergesort, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tama침o de la lista')
plt.ylabel('Tiempo de ejecuci칩n (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Mergesort')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()


endtime7 = end_time7
lastsize7 = i7

"""**8 Count sort**"""

import random
import time
import matplotlib.pyplot as plt


#metodo de ordenamiento countsort
def count_sort(lista, maximo):
    """M칠todo de ordenamiento countsort."""
    lista_conteo = [0] * (maximo + 1)
    lista_ordenada = [None] * len(lista)

    for i in lista:
        lista_conteo[i] += 1

    total = 0
    for i in range(len(lista_conteo)):
        lista_conteo[i], total = total, total + lista_conteo[i]

    for indice in lista:
        lista_ordenada[lista_conteo[indice]] = indice
        lista_conteo[indice] += 1

    return lista_ordenada


#tama침o de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_countsort = []

#generar lista aleatoria
for i8 in size:
  array = [random.randint(0,100) for _ in range(i8)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time8 = time.perf_counter()
  Lista_ordenada_count_sort = count_sort(array, max(array))
  end_time8 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time8}")
  print(f"tiempo final: {end_time8}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_count_sort}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time8 - start_time8
  execution_times_countsort.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tama침o {i8}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecuci칩n       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_countsort):
    print(f"Tama침o: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gr치fica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_countsort, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tama침o de la lista')
plt.ylabel('Tiempo de ejecuci칩n (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Count Sort')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime8 = end_time8
lastsize8 = i8




# Usamos las variables ya existentes para comparar la eficiencia de los algoritmos

import matplotlib.pyplot as plt

# Asumimos que tienes variables como:
# execution_times_burbuja, execution_times_burbuja_mejorado, execution_times_coctel, etc.
# Y que cada una es una lista de tiempos para los distintos tama침os de lista.
# Para comparar el m치s eficiente en el 칰ltimo tama침o (por ejemplo, n=4000):

# Nombres de los algoritmos
algoritmos = [
    'Burbuja',
    'Burbuja Mejorado',
    'Coctel',
    'Selecci칩n',
    'Inserci칩n',
    'Quicksort',
    'Mergesort',
    'Count Sort'
]

# Obtenemos el 칰ltimo tiempo de cada algoritmo (para el tama침o m치s grande)
# Aseg칰rate de que estas variables existen y est치n actualizadas en tu c칩digo principal
tiempos_ejecucion = [
    execution_times_burbuja[-1],
    execution_times_burbuja_mejorado[-1],
    execution_times_coctel[-1],
    execution_times_seleccion[-1],
    execution_times_insercion[-1],
    execution_times_quicksort[-1],
    execution_times_mergesort[-1],
    execution_times_countsort[-1],# Count Sort, ya que tu variable es 'execution_times'
]

# Crear la figura y los ejes para la gr치fica
plt.figure(figsize=(12, 8))

# Crear la gr치fica de barras
barras = plt.bar(algoritmos, tiempos_ejecucion, color='skyblue')

# A침adir t칤tulos y etiquetas
plt.xlabel('Algoritmo de Ordenamiento')
plt.ylabel('Tiempo de Ejecuci칩n (segundos)')
plt.title(f'Comparaci칩n de Eficiencia de Algoritmos (para n={lastsize8})')
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y', linestyle='--', alpha=0.7)

# A침adir el valor exacto encima de cada barra
for barra in barras:
    yval = barra.get_height()
    plt.text(barra.get_x() + barra.get_width()/2.0, yval, f'{yval:.4f}', va='bottom', ha='center')

plt.tight_layout()
plt.show()




"""burbuja(lista): El m칠todo m치s intuitivo. Compara cada elemento con el siguiente y los intercambia si est치n en el orden incorrecto. Repite este proceso una y otra vez, haciendo que los elementos m치s grandes "floten" como burbujas hacia el final de la lista.

burbuja_mejorado(lista): Una versi칩n m치s inteligente del anterior. Si en una pasada completa por la lista no hace ning칰n intercambio, significa que la lista ya est치 ordenada y el algoritmo se detiene para no trabajar de m치s.

coctel(lista) (o Cocktail Shaker Sort): Es una variante del burbuja. En lugar de ir siempre en una direcci칩n, va de izquierda a derecha (llevando el m치s grande al final) y luego de derecha a izquierda (llevando el m치s peque침o al inicio). Es como sacudir una coctelera. 游꽂

seleccion(lista): Este algoritmo busca el elemento m치s peque침o de toda la lista y lo pone en la primera posici칩n. Luego, busca el segundo m치s peque침o y lo pone en la segunda posici칩n, y as칤 sucesivamente.

insercion(lista): Funciona como cuando ordenas cartas en tu mano. Tomas una carta (un elemento) y la vas insertando en el lugar correcto dentro de las que ya tienes ordenadas.

quicksort(lista): Un algoritmo muy popular y eficiente. Utiliza la estrategia "divide y vencer치s". Elige un elemento como "pivote", y divide la lista en dos: los menores al pivote y los mayores al pivote. Luego, repite el proceso recursivamente con las dos sub-listas hasta que todo est치 ordenado.

mergesort(lista): Otro algoritmo de "divide y vencer치s". Parte la lista por la mitad repetidamente hasta tener muchas listas de un solo elemento. Luego, las va uniendo (fusionando o merge) de dos en dos de manera ordenada hasta tener la lista completa ordenada de nuevo. La funci칩n merge es su ayudante para hacer esta fusi칩n.

count_sort(lista, maximo): Este es un algoritmo especial. No compara elementos entre s칤. En su lugar, cuenta cu치ntas veces aparece cada n칰mero. Luego, usa esas cuentas para reconstruir la lista ya ordenada. Es extremadamente r치pido, pero tiene una desventaja: solo funciona bien con n칰meros enteros y cuando conoces el rango de valores (de 0 al maximo).
"""